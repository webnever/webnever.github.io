<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <title>AETHER WEBNEVER</title>
    <style>
        @font-face {
            font-family: 'Terminal';
            src: url('tooth31-medium-webfont.ttf') format('truetype');
        }

        :root {
            --text-color: #00ff00;
            --bg-color: #000000;
            --timestamp-color: #888888;
            --font-size: 24px;
            --line-spacing: 8px;
            --cursor-width: 10px;
            --cursor-height: 20px;
            --image-width: 500px;
            --image-height: 500px;
            /* New position range variables */
            --image-top-min: 0;
            /* Minimum top position percentage */
            --image-top-max: 40;
            /* Maximum top position percentage */
            --image-left-min: 60;
            /* Minimum left position percentage */
            --image-left-max: 65;
            /* Maximum left position percentage */
        }

        /* Previous styles remain the same until image-wrapper */
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Terminal', monospace;
            margin: 0;
            padding: 0;
            font-size: var(--font-size);
            letter-spacing: 0.5em;
            white-space: pre;
        }

        #terminal-container {
            height: 100vh;
            overflow-y: auto;
            position: fixed;
            width: 100%;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #terminal {
            padding: 20px;
        }

        .terminal-line {
            opacity: 0;
            margin-bottom: var(--line-spacing);
            white-space: pre-wrap;
        }

        .timestamp {
            color: var(--timestamp-color);
            margin-right: 15px;
        }

        .cursor {
            display: inline-block;
            width: var(--cursor-width);
            height: var(--cursor-height);
            background-color: var(--text-color);
            margin-left: 5px;
            animation: blink 1s step-end infinite;
            position: relative;
        }

        @keyframes blink {

            0%,
            50% {
                opacity: 1;
            }

            51%,
            100% {
                opacity: 0;
            }
        }

        .image-wrapper {
            position: fixed;
            width: var(--image-width);
            height: var(--image-height);
            z-index: 2;
            pointer-events: none;
        }

        .image-wrapper img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }

        .image-wrapper img.visible {
            opacity: 1;
        }
    </style>
</head>

<body>
    <div id="imageWrapper1" class="image-wrapper">
        <img id="displayImage1">
    </div>
    <div id="imageWrapper2" class="image-wrapper">
        <img id="displayImage2">
    </div>

    <audio id="backgroundMusic" preload="auto">
        <source src="hills.mp3" type="audio/mpeg">
    </audio>
    <div id="terminal-container">
        <div id="terminal"></div>
        <div class="cursor"></div>
    </div>

    <script>
        // Customizable parameters
        const CONFIG = {
            // Timing (in milliseconds)
            fadeInDelay: 75,      // Delay before each line starts fading in
            lineDelay: 75,       // Delay between lines
            fadeInDuration: 75,   // How long the fade in animation takes

            // Cursor
            cursorBlinkRate: 1000, // Milliseconds for one complete blink cycle

            // Text content
            lines: [
                "              ........              ",
                "         .d$$$$*$$$$$$bc         ",
                "      .d$P\"    d$$    \"*$$.      ",
                "     d$\"      4$\"$$      \"$$.    ",
                "   4$P        $F ^$F       \"$c   ",
                "  z$%        d$   3$        ^$L  ",
                " 4$$$$$$$$$$$$$$$$$$$$$$$$$$F ",
                " $$$F\"\"\"\"\"\"\"$F\"\"\"\"\"\"$F\"\"\"\"\"C$$*$ ",
                ".$%\"$$e    d$       3$   z$$\"  $F",
                "4$    *$$.4$\"        $$d$P\"    $$",
                "4$      ^*$$.       .d$F       $$",
                "4$       d$\"$$c   z$$\"3$       $F",
                " $L     4$\"  ^*$$$P\"   $$     4$\"",
                " 3$     $F   .d$P$$e   ^$F    $P ",
                "  $$   d$  .$$\"    \"$$c 3$   d$  ",
                "   *$.4$\"z$$\"        ^*$$$$ $$   ",
                "    \"$$$$P\"             \"$$$P    ",
                "      *$b.             .d$P\"     ",
                "        \"$$$ec.....ze$$$\"        ",
                "            \"**$$$**\"\"            ",
                "",
                "",
                "NoWareOS [Version 88614] ðŸ•¸ðŸ•Š",
                "(c) 20dX NoWare(tm). All Rights Reserved.",
                "",
                "",
                "AETHER WEBNEVER CHRONICLES",
                "",
                "",
                "The", "bunker", "door", "opens", "for", "the", "first", "time", "in", "years", "M.M.", "emerges", "into", "the", "perpetual", "dusk", "of", "a", "world", "he", "no", "longer", "recognizes", "Above", "a", "crescent", "moon", "hangs", "motionless", "beneath", "a", "burning", "pentagram", "that", "splits", "the", "sky", "both", "frozen", "in", "time", "since", "the", "Black", "Bomb", "changed", "everything",
                "His", "motorcycle", "stands", "ready", "its", "chrome", "untarnished", "despite", "the", "years", "underground", "He", "doesn't", "remember", "preparing", "it", "but", "he", "knows", "it's", "meant", "for", "him", "The", "engine", "starts", "with", "a", "sound", "like", "a", "distant", "scream",
                "Through", "the", "swirling", "sand", "two", "monuments", "pierce", "the", "horizon", "a", "pyramid", "of", "black", "stone", "that", "seems", "to", "absorb", "light", "and", "the", "massive", "corpse", "of", "a", "dragon", "its", "iridescent", "scales", "still", "shifting", "colors", "in", "death", "M.M.", "feels", "drawn", "to", "both", "yet", "understanding", "neither", "The", "desert", "between", "here", "and", "there", "is", "vast", "empty",
                "The", "first", "ride", "is", "interrupted", "by", "gunfire", "A", "figure", "on", "horseback", "emerges", "from", "the", "heat", "waves", "a", "Jackal", "its", "face", "obscured", "by", "cascading", "streams", "of", "green", "matrix", "code", "that", "forms", "a", "digital", "skull", "The", "same", "code", "that", "flickers", "at", "the", "edges", "of", "M.M.'s", "own", "vision",
                "BROTHER", "the", "Jackal's", "voice", "crackles", "like", "corrupted", "data", "THE", "6", "WILL", "CARRY", "YOU", "TO", "HELL",
                "Before", "M.M.", "can", "process", "these", "words", "an", "armored", "helicopter", "materializes", "upon", "the", "horizon", "The", "6", "Dragon", "Team", "their", "armor", "marked", "with", "an", "ouroboros", "a", "dragon", "forever", "consuming", "itself", "The", "number", "6", "on", "their", "insignias", "seems", "to", "shift", "direction", "pointing", "sometimes", "up", "sometimes", "down",
                "Weapon", "raised", "a", "6", "Dragon", "Member", "calls", "out", "from", "the", "helicopter", "There", "is", "only", "Peace", "Corps", "Illumined", "now",
                "The", "Jackal's", "horse", "rears", "YOU", "WILL", "PAY", "THE", "PRICE", "OF", "IMMORTALITY",
                "A", "firefight", "erupts", "M.M.", "finds", "himself", "diving", "instinctively", "behind", "his", "motorcycle", "his", "body", "remembering", "combat", "training", "his", "mind", "cannot", "recall", "Through", "his", "matrix", "vision", "he", "sees", "the", "bullets", "leave", "trails", "of", "binary", "code", "in", "the", "air",
                "The", "Jackal", "vanishes", "into", "the", "desert", "but", "the", "6", "Dragon", "Team", "remains", "They", "lower", "their", "weapons",
                "Who", "are", "you",
                "They", "escort", "M.M.", "to", "a", "hidden", "facility", "beneath", "the", "dragon", "corpse", "Scientists", "in", "hazmat", "suits", "study", "its", "decomposition", "but", "through", "his", "matrix", "vision", "M.M.", "sees", "what", "they're", "really", "studying", "time", "itself", "flowing", "backward", "through", "the", "dragon's", "veins",
                "In", "the", "deepest", "chamber", "he", "meets", "the", "King", "a", "figure", "both", "young", "and", "ancient", "simultaneously", "as", "if", "two", "versions", "of", "the", "same", "man", "are", "trying", "to", "occupy", "the", "same", "space", "Through", "the", "matrix", "code", "M.M.", "sees", "them", "flicker", "between", "positions", "one", "on", "the", "throne", "one", "hooked", "to", "life", "support", "machines",
                "You've", "come", "M.M.", "both", "versions", "speak", "in", "unison", "and", "as", "if", "talking", "to", "an", "old", "friend",
                "The", "King's", "younger", "self", "holds", "up", "a", "ceremonial", "chalice", "The", "older", "self's", "monitors", "flash", "warnings", "in", "code", "only", "M.M.", "can", "read",
                "DRINK", "THE", "BLOOD", "FOR", "THE", "GREAT", "FLOOD", "<3",
                "A", "glowing", "blue", "butterfly", "lands", "on", "the", "chalice's", "rim",
                "They", "are", "coming", "and", "they're", "singing", "an", "old", "world", "hymn", "about", "the", "end", "of", "time",
            ],
            // Style
            timestampPrecision: 3  // Number of decimal places for milliseconds
        };

        const images = [
            "tarot/1.png",
            "tarot/2.png",
            "tarot/3.png",
            "tarot/4.png",
            "tarot/5.png",
            "tarot/6.png",
            "tarot/7.png",
            "tarot/8.png",
            "tarot/9.png",
            "tarot/10.png",
        ];

        let audio = document.getElementById('backgroundMusic');
        let availableImages = [...images];
        let lastTime = 0;
        let currentWrapper = 1;
        const wrapper1 = document.getElementById('imageWrapper1');
        const wrapper2 = document.getElementById('imageWrapper2');
        const image1 = document.getElementById('displayImage1');
        const image2 = document.getElementById('displayImage2');

        let userIsScrolling = false;
        let isAtBottom = true;

        // Track time intervals for image changes
        let lastImageChange = 0;
        const IMAGE_CHANGE_INTERVAL = 8000; // Change image every 5 seconds

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function getRandomPosition() {
            const root = document.documentElement;
            const topMin = parseFloat(getComputedStyle(root).getPropertyValue('--image-top-min'));
            const topMax = parseFloat(getComputedStyle(root).getPropertyValue('--image-top-max'));
            const leftMin = parseFloat(getComputedStyle(root).getPropertyValue('--image-left-min'));
            const leftMax = parseFloat(getComputedStyle(root).getPropertyValue('--image-left-max'));

            const randomTop = Math.random() * (topMax - topMin) + topMin;
            const randomLeft = Math.random() * (leftMax - leftMin) + leftMin;
            return { top: `${randomTop}%`, left: `${randomLeft}%` };
        }

        function changeImage() {
            if (availableImages.length === 0) {
                availableImages = [...images];
                shuffleArray(availableImages);
            }

            const nextImageSrc = availableImages.pop();
            const newPosition = getRandomPosition();

            const nextWrapper = currentWrapper === 1 ? wrapper2 : wrapper1;
            const nextImageElement = currentWrapper === 1 ? image2 : image1;

            nextWrapper.style.top = newPosition.top;
            nextWrapper.style.left = newPosition.left;
            nextImageElement.src = nextImageSrc;

            if (currentWrapper === 1) {
                image2.classList.add('visible');
                image1.classList.remove('visible');
            } else {
                image1.classList.add('visible');
                image2.classList.remove('visible');
            }

            currentWrapper = currentWrapper === 1 ? 2 : 1;
            lastImageChange = Date.now();
        }

        function checkImageUpdate() {
            const now = Date.now();
            if (now - lastImageChange >= IMAGE_CHANGE_INTERVAL) {
                changeImage();
            }
            requestAnimationFrame(checkImageUpdate);
        }

        window.addEventListener('load', function () {
            shuffleArray(availableImages);

            // Set initial images
            const firstImage = availableImages.pop();
            const secondImage = availableImages.pop();
            const pos1 = getRandomPosition();
            const pos2 = getRandomPosition();

            wrapper1.style.top = pos1.top;
            wrapper1.style.left = pos1.left;
            image1.src = firstImage;
            image1.classList.add('visible');

            wrapper2.style.top = pos2.top;
            wrapper2.style.left = pos2.left;
            image2.src = secondImage;

            lastImageChange = Date.now();

            // Start the image update loop
            checkImageUpdate();

            // Handle audio
            audio.loop = true;
            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.catch(function (error) {
                    console.log("Autoplay was prevented by the browser");
                });
            }
        });

        function updateFromURLParams() {
            const params = new URLSearchParams(window.location.search);
            const root = document.documentElement;

            const cssVars = {
                'textColor': '--text-color',
                'bgColor': '--bg-color',
                'timestampColor': '--timestamp-color',
                'fontSize': '--font-size',
                'lineSpacing': '--line-spacing',
                'cursorWidth': '--cursor-width',
                'cursorHeight': '--cursor-height',
                'imageTopMin': '--image-top-min',
                'imageTopMax': '--image-top-max',
                'imageLeftMin': '--image-left-min',
                'imageLeftMax': '--image-left-max'
            };

            for (const [param, cssVar] of Object.entries(cssVars)) {
                if (params.has(param)) {
                    let value = params.get(param);
                    if (['fontSize', 'lineSpacing', 'cursorWidth', 'cursorHeight'].includes(param)) {
                        value += 'px';
                    }
                    root.style.setProperty(cssVar, value);
                }
            }
        }

        const startTime = Date.now();

        function formatElapsedTime() {
            const elapsed = Date.now() - startTime;
            const seconds = Math.floor(elapsed / 1000);
            const milliseconds = elapsed % 1000;
            return `[${String(seconds).padStart(2, '0')}.${String(milliseconds).padStart(CONFIG.timestampPrecision, '0')}]`;
        }

        function createLine(text) {
            const line = document.createElement('div');
            line.className = 'terminal-line';

            const timestamp = document.createElement('span');
            timestamp.className = 'timestamp';
            timestamp.textContent = formatElapsedTime();

            line.appendChild(timestamp);
            line.appendChild(document.createTextNode(text));
            return line;
        }

        async function printLines() {
            const terminal = document.getElementById('terminal');
            const container = document.getElementById('terminal-container');
            const cursor = document.querySelector('.cursor');

            // Add scroll event listener
            container.addEventListener('scroll', () => {
                // Check if user has scrolled up
                const maxScroll = container.scrollHeight - container.clientHeight;
                isAtBottom = Math.abs(container.scrollTop - maxScroll) < 10;
                
                // If user scrolls up, mark as manual scrolling
                if (!isAtBottom) {
                    userIsScrolling = true;
                }
                
                // If user scrolls to bottom, resume automatic scrolling
                if (isAtBottom) {
                    userIsScrolling = false;
                }
            });

            const moveCursor = () => {
                terminal.appendChild(cursor);
            };

            for (const text of CONFIG.lines) {
                const line = createLine(text);
                terminal.appendChild(line);
                moveCursor();

                // Only auto-scroll if user isn't manually scrolling
                if (!userIsScrolling) {
                    container.scrollTop = container.scrollHeight;
                }

                await new Promise(resolve => setTimeout(resolve, CONFIG.fadeInDelay));
                line.style.transition = `opacity ${CONFIG.fadeInDuration}ms`;
                line.style.opacity = '1';

                await new Promise(resolve => setTimeout(resolve, CONFIG.lineDelay));
            }
        }

        updateFromURLParams();
        printLines();
    </script>
</body>

</html>